:py:mod:`cubewalkers`
=====================

.. py:module:: cubewalkers


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   conversions/index.rst
   custom_typing/index.rst
   experiment/index.rst
   initial_conditions/index.rst
   model/index.rst
   parser/index.rst
   simulation/index.rst
   update_schemes/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   cubewalkers.Experiment
   cubewalkers.Model




Attributes
~~~~~~~~~~

.. autoapisummary::

   cubewalkers.__version__


.. py:class:: Experiment(override_string: str, comment_char: str = '#')


   Stores information from user-specified experimental inputs.

   :param override_string: Experimental conditions to incorporate. Each line should be in one of the following forms:

                           - NodeName,StartTime,EndTime,RuleToSubstitute
                           - ParentName-->NodeName,StartTime,EndTime,RuleToSubstitute

                           If NodeName ends in a '*', then update is not forced (i.e., the update
                           rule becomes fixed to RuleToSubstitute). Otherwise, update is forced,
                           and the node NodeName takes the value RuleToSubstitute at each time
                           step. Note that this does not make any difference in synchronous update.
                           The control can be made permanent by specifying an EndTime of inf.
                           If NodeName is preceded by 'ParentName-->', then RuleToSubstitute replaces
                           all occurences of ParentName in the update rule for NodeName, and the
                           update is never forced. Specifying conflicting controls is not supported
                           and may lead to undefined behavior.
   :type override_string: str
   :param comment_char: Empty lines and lines beginning with this character are ignored, by default '#'.
   :type comment_char: str, optional

   .. py:method:: new_rule(old_rule: str) -> str

      Modifies an input rule to incorporate the time-dependent experimental conditions
      stored internally.

      :param old_rule: Rule to modify.
      :type old_rule: str

      :returns: Modified rule, with time dependence.
      :rtype: str


   .. py:method:: time_clamp_string(varnames: Iterable[str]) -> str

      Generates and returns a string that determines when the update mask should
      be ignored because of the experimental conditions.

      :param varnames: Names of the variables in the system.
      :type varnames: Iterable[str]

      :returns: String that is interperable as a C++ Boolean expression. When this evaluates
                to true, the update mask is ignored and an update is performed.
      :rtype: str



.. py:class:: Model(rules: str | None = None, lookup_tables: cupy.typing.NDArray | None = None, node_regulators: Iterable[Iterable[int]] | None = None, lookup_table_varnames: Iterable[str] | None = None, initial_biases: str = '', model_name: str | None = None, experiment: cubewalkers.experiment.Experiment | None = None, comment_char: str = '#', n_time_steps: int = 1, n_walkers: int = 1)


   Stores a Boolean network and experimental conditions, as well as generates
   and stores the results of simulations on that network.

   :param rules: Rules to input. If skip_clean is `True` (not default), then these
                 are assumed to have been cleaned. If not provided, then
                 `lookup_tables` and `node_regulators` must both be provided instead.
   :type rules: str, optional
   :param lookup_tables: A merged lookup table that contains the output column of each rule's
                         lookup table (padded by `False` values). If not provided, rules must
                         be provided instead.
   :type lookup_tables: cp.NDArray, optional
   :param node_regulators: Iterable i should contain the indicies of the nodes that regulate
                           node i, optionally padded by negative values. If not provided, rules
                           must be provided instead.
   :type node_regulators: Iterable[Iterable[int]]
   :param lookup_table_varnames: Iterable of variable names to associate with lookup table entries.
                                 If `None` (default) dummy variable names of the form 'x0', 'x1',
                                 etc., will be constructed.
   :type lookup_table_varnames: Iterable[str], optional
   :param initial_biases: Each line should be of the form - NodeName,bias where NodeName is
                          the name of the node, and bias is the probability that the node will
                          be initialized to `1` (instead of 0). Nodes whose names are not listed
                          are given a bias of 0.5 by default.
   :type initial_biases: str
   :param model_name: A name for the kernel.
   :type model_name: str
   :param experiment: An :class:`Experiment<cubewalkers.experiment.Experiment>` object
                      specifying experimental conditions, by default None, in which case
                      no experimental conditions are incorporated into the rules.
                      Currently not implemented for lookup-table-based Boolean networks.
   :type experiment: Experiment | None, optional
   :param comment_char: In rules, empty lines and lines beginning with this character are
                        ignored, by default `'#'`.
   :type comment_char: str, optional
   :param n_time_steps: Number of timesteps to simulate, by default `1`.
   :type n_time_steps: int, optional
   :param n_walkers: Number of ensemble walkers to simulate, by default `1`.
   :type n_walkers: int, optional

   .. py:method:: initialize_walkers() -> None

      Generates initial conditions from internally stored data. See the
      `initial_conditions` module for details.


   .. py:method:: simulate_ensemble(T_window: int | None = None, averages_only: bool = False, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32), set_update_prob: float = 0.5) -> None

      Simulates a random ensemble of walkers on the internally stored Boolean
      network. Results are stored in the trajectories attribute.

      :param T_window: Number of time points to keep (from t=T-T_window+1 to t=T). If
                       `None` (default), keep all time points.
      :type T_window: int, optional
      :param averages_only: If True, stores only average node values at each timestep.
                            Otherwise, stores node values for each walker. By default `False`.
      :type averages_only: bool, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for details.
      :type threads_per_block: tuple[int, int], optional


   .. py:method:: trajectory_variance(initial_state: cupy.NDarray[cupy.bool_], n_time_steps: int | None = None, n_walkers: int | None = None, maskfunction: cubewalkers.custom_typing.MaskFunctionType = asynchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDarray

      Returns the variance of trajectories that begin at the specified initial
      state. Note that the covariances are not, in general, zero.

      :param initial_state: The initial state to use. Will cast to `cupy.bool` if other dtype is
                            provided.
      :type initial_state: cp.NDArray[cp.bool]
      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the impact. By default, use
                        internally stored variable `n_walkers`, which itself defaults to `1`.
      :type n_walkers: int | None, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for details.
      :type threads_per_block: tuple[int, int], optional

      :returns: Variance of trajectories
      :rtype: cp.NDArray


   .. py:method:: dynamical_impact(source_var: str | list[str], n_time_steps: int | None = None, n_walkers: int | None = None, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDArray

      Computes the dynamical impact of the source node index on all others
      (including itself, from time=0 to time=T).

      :param source_var: Name(s) of variable(s) to find dynamical impact of.
      :type source_var: str | list[str]
      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the impact. By default, use
                        internally stored variable `n_walkers`, which itself defaults to `1`.
      :type n_walkers: int | None, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples. For dynamical
                           impact, if the maskfunction is state-dependent, then the unperturbed
                           trajectory is used.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for details.
      :type threads_per_block: tuple[int, int], optional

      :returns: `(n_time_steps+1)` x `n_variables` array of dynamical impacts of the
                source at each time. Refer to `vardict` member variable to see
                ordering of variables. Note that the initial time impact is always
                maximal for the source node and minimal for all others.
      :rtype: cp.NDArray


   .. py:method:: source_quasicoherence(source_var: str | list[str], n_time_steps: int | None = None, n_walkers: int | None = None, T_sample: int = 1, fuzzy_coherence: bool = False, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDArray

      Computes the quasicoherence in response to perturbation of source node
      index, averaging trajectories from t=T-T_sample+1 to T.

      :param source_var: Name(s) of variable(s) to find coherence with respect to.
      :type source_var: str | list[str]
      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the coherence. By default, use
                        internally stored variable `n_walkers`, which itself defaults to `1`.
      :type n_walkers: int | None, optional
      :param T_sample: Number of time points to use for averaging (t=T-T_sample+1 to t=T),
                       by default, `1`.
      :type T_sample: int, optional
      :param fuzzy_coherence: If `False` (default), trajectroies are marked as either in agreement
                              (`1`) or not in agreement (`0`) depending on whether fixed nodes are in
                              agreement. If True, the average absolute difference between state
                              vectors is used instead.
      :type fuzzy_coherence: bool, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples. For coherence, if
                           the maskfunction is state-dependent, then the unperturbed trajectory
                           is used.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for details.
      :type threads_per_block: tuple[int, int], optional

      :returns: The estimated value of the quasicoherence response to the source
                node perturbation.
      :rtype: cp.NDArray


   .. py:method:: quasicoherence(n_time_steps: int | None = None, n_walkers: int | None = None, T_sample: int = 1, fuzzy_coherence: bool = False, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDArray

      Computes the quasicoherence in response to perturbation of single nodes,
      averaging trajectories from t=T-T_sample+1 to T.

      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the coherence. By default, use
                        internally stored variable `n_walkers`, which itself defaults to
                        `1`.
      :type n_walkers: int | None, optional
      :param T_sample: Number of time points to use for averaging (t=T-T_sample+1 to t=T),
                       by default, `1`.
      :type T_sample: int, optional
      :param fuzzy_coherence: If `False` (default), trajectories are marked as either in agreement
                              (`1`) or not in agreement (`0`) depending on whether fixed nodes are
                              in agreement. If True, the average absolute difference between state
                              vectors is used instead.
      :type fuzzy_coherence: bool, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cupewalkers.update_schemes` for examples. For coherence, if
                           the maskfunction is state-dependent, then the unperturbed trajectory
                           is used.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for
                                details.
      :type threads_per_block: tuple[int, int], optional

      :returns: The estimated value of the quasicoherence response to single node
                perturbations.
      :rtype: cp.NDArray


   .. py:method:: source_final_hamming_distance(source_var: str | list[str], n_time_steps: int | None = None, n_walkers: int | None = None, T_sample: int = 1, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDArray

      Computes the final hamming distance in response to perturbation of
      source node index, averaging hamming distances from t=T-T_sample+1 to T.

      :param source_var: Name(s) of variable(s) to find the Hamming distance with respect to.
      :type source_var: str | list[str]
      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the final Hamming distance. By
                        default, use internally stored variable `n_walkers`, which itself
                        defaults to `1`.
      :type n_walkers: int | None, optional
      :param T_sample: Number of time points to use for averaging (t=T-T_sample+1 to t=T),
                       by default, `1`.
      :type T_sample: int, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for
                                details.
      :type threads_per_block: tuple[int, int], optional

      :returns: The estimated value of the final Hamming distance response to the
                source node perturbation.
      :rtype: cp.NDArray


   .. py:method:: final_hamming_distance(n_time_steps: int | None = None, n_walkers: int | None = None, T_sample: int = 1, maskfunction: cubewalkers.custom_typing.MaskFunctionType = synchronous, threads_per_block: tuple[int, int] = (32, 32)) -> cupy.NDArray

      Computes the final Hamming distance in response to perturbation of
      single nodes, averaging Hamming distances from t=T-T_sample+1 to T.

      :param n_time_steps: Number of timesteps to simulate. By default, use internally stored
                           variable `n_time_steps`, which itself defaults to `1`.
      :type n_time_steps: int | None, optional
      :param n_walkers: How many walkers to use to estimate the final Hamming distance. By
                        default, use internally stored variable `n_walkers`, which itself
                        defaults to `1`.
      :type n_walkers: int | None, optional
      :param T_sample: Number of time points to use for averaging (t=T-T_sample+1 to t=T),
                       by default, `1`.
      :type T_sample: int, optional
      :param maskfunction: Function that returns a mask for selecting which node values to
                           update. By default, uses the synchronous update scheme. See
                           :mod:`cubewalkers.update_schemes` for examples.
      :type maskfunction: MaskFunctionType, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for
                                details.
      :type threads_per_block: tuple[int, int], optional

      :returns: The estimated value of the final Hamming distance response to single
                node perturbations.
      :rtype: cp.NDArray


   .. py:method:: derrida_coefficient(n_walkers: int | None = None, threads_per_block: tuple[int, int] = (32, 32)) -> float

      Estimates the (synchronous) Derrida coefficient.

      The Derrida coefficent is computed as the mean Hamming distance after
      one synchronous update between trajectories with initial Hamming
      distance of one. For analogs using other update schemes, use
      :meth:`dynamical_impact`.

      :param n_walkers: How many walkers to use to estimate the Coefficient. By default, use
                        internally stored variable `n_walkers`, which itself defaults to
                        `1`.
      :type n_walkers: int | None, optional
      :param threads_per_block: How many threads should be in each block for each dimension of the N
                                x W array, by default `(32, 32)`. See CUDA documentation for
                                details.
      :type threads_per_block: tuple[int, int], optional

      :returns: Estimate of the Derrida coefficient.
      :rtype: float



.. py:data:: __version__
   :value: '1.4.0'

   

